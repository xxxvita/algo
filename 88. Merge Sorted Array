/*
Данный алгоритм на языке Go выполняет слияние двух отсортированных массивов `nums1` и `nums2` в `nums1`. Алгоритм имеет временную сложность O(n), где n - суммарный размер обоих массивов, и использует константное количество дополнительной памяти O(1).

Алгоритм начинает сравнивать элементы справа от конца обоих массивов. Указатели `l` и `r` указывают на последние элементы в `nums1` и `nums2` соответственно. Указатель `pos` указывает на текущую позицию в `nums1`, куда будет записан следующий элемент.

Алгоритм выполняет следующие действия до тех пор, пока указатели `l` и `r` не достигнут начала своих массивов:

- Если указатель `l` достиг начала массива `nums1`, то оставшиеся элементы из `nums2` записываются в `nums1` начиная с позиции `pos` и уменьшается значение указателя `r`.
- Если указатель `r` достиг начала массива `nums2`, то оставшиеся элементы из `nums1` записываются в `nums1` начиная с позиции `pos` и уменьшается значение указателя `l`.
- Если элемент из `nums1` по указателю `l` больше элемента из `nums2` по указателю `r`, то этот элемент записывается в `nums1` на позицию `pos`, уменьшается значение указателя `l` и уменьшается значение `pos`.
- Если элемент из `nums2` по указателю `r` больше элемента из `nums1` по указателю `l`, то этот элемент записывается в `nums1` на позицию `pos`, уменьшается значение указателя `r` и уменьшается значение `pos`.
- Если элементы из `nums1` и `nums2` по указателям `l` и `r` соответственно равны, то сначала элемент из `nums1` записывается в `nums1` на позицию `pos`, затем элемент из `nums2` записывается в `nums1` на позицию `pos-1`, уменьшаются значения указателей `l`, `r` и уменьшается значение `pos` на 2.

После завершения цикла слияние массивов будет завершено, и массив `nums1` будет содержать объединенные и отсортированные элементы из обоих массивов.
*/

// Time: O(n)
// mem: O(1)
func merge(nums1 []int, m int, nums2 []int, n int)  {
    l := m-1
    r := n-1

    pos := len(nums1)-1
    //nums1 = [1,0] m = 1 nums2 = [2] n = 1
    for l >= 0 || r >= 0 {
        if l < 0 {
            nums1[pos] = nums2[r]
            r--
            pos--
            continue
        }
        if r < 0 {
            nums1[pos] = nums1[l]
            l--
            pos--
            continue
        }

        if nums1[l] > nums2[r] {
            nums1[pos] = nums1[l]
            l--
            pos--
            continue
        }

        if nums2[r] > nums1[l] {
            nums1[pos] = nums2[r]
            r--
            pos--
            continue
        }

        if nums2[r] == nums1[l] {
            nums1[pos] = nums1[l]
            pos--
            nums1[pos] = nums2[r]
            pos--
            l--
            r--
        }
    }
}
