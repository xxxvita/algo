//time: O(n)
//mem: O(n)
/*В случае односвязного списка единственный способ найти конец списка, а значит, и n-ый узел из конца, - это выполнить итерацию до конца. Задача состоит в том, чтобы найти решение только за один проход. Наивным подходом здесь может быть хранение указателей на каждый узел в массиве, что позволит нам вычислить n-й узел из конца, когда мы достигнем конца, но это займет O(M) дополнительного места, где M - длина связанного списка.

Другим подходом было бы хранение в массиве только последних n+1 указателей узлов. Этого можно добиться, перезаписывая элементы массива по кругу по мере прохождения по списку. Это позволило бы снизить пространственную сложность до o(N+1).
*/
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	fast, slow := head, head
	for i := 0; i < n; i++ {
		fast = fast.Next
	}
	if fast == nil {
		return head.Next
	}
	for fast.Next != nil {
		fast = fast.Next
		slow = slow.Next
	}
	slow.Next = slow.Next.Next
	return head
}
//c
