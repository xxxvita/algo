//idea: Создаётся массив префиксных сумм, который позволит считать суммы
//      последовательности наиболее быстро.
//      Решение будет строится на идее, что если префиксная сумма всё время растёт,
//      то решение быстрее придёт к саммым ранее стоящим элементам массива.
//      Т.о. я буду вести очередь в которой я ищу (начиная с нулевого элемента)
//      индексы, которые только что получили достижение до суммы не менее K.
//      Если сумма набрана, то все элементы с решением удаляются.
//      На каждой итерации пересчитывается минимальная длина подмассива.
//      Также используется оптимизация: если префиксная сумма текущей итерации
//      приводит к снижению накопленной суммы, то это значит, что встретился
//      отрицательный элемент и это приводит к выводу, что такой отрицательный
//      элемент не может привести к решению раньше, чем элементы до него и, что
//      самое интересное, то это то, что и предыдущий элемент до отрицательного
//      теперь тоже не может получить решение быстрее, чем элемент до него.
//      Т.о. при снижении префиксной суммы, я удаляю последние два элемента из
//      очереди. В моей конкретной реализации удаляется один последний, т.к. не 
//      добавляется с суммой ниже. Это хорошая оптимизация. Т.о. очередь сильно
//      не разрастается и в ней всегда такие элементы, сумма которых не доходит
//      до k.

// Time: O(nlogn) сортировка, + двоичный поиск n раз, где n - это len(nums); 
// added mem: O(n) сортированные префиксные суммы
func shortestSubarray(nums []int, k int) int {
    prefix := make([]int, len(nums)+1)
    for i:=0; i<len(nums); i++ {
        prefix[i+1] = prefix[i] + nums[i]
    }
    
    // Ответ
    minLen := 1<<32
    // Очередь запросов префиксных сумм
    qSum := make([]int, 0)

    //+Input: nums = [1], k = 1
    //Output: 1
    //masPrefix: [[1,0]]
    
    //Example 2:
    //Input: nums = [1,2], k = 4
    //Output: -1
    //masPrefix: [[1,0][3,1]]

    //Example 3:
    //Input: nums = [2,-1,2], k = 3  
    //Output: 3
    //masPrefix: [[2,0][1,1][3,2]]   
    for i:=0; i<len(prefix); i++ { //0, 1, 2
        //[2]   [-1]   [2]
        //[2,0],[1,1], [3,2]; k==3;
        for len(qSum) > 0 && prefix[i] - prefix[qSum[0]] >= k {
                // Текущая префиксная сумма проверяется как ответ на предыдущие запросы
                minLen = min(i-qSum[0], minLen) //3, 2, 3
                // Быстрее всего должны ответ получить первые добавленные элементы в очередь.
                // Они и удаляются первыми при достяжении суммы
                qSum = qSum[1:]
        }
        for len(qSum) > 0 && prefix[i] < prefix[qSum[len(qSum)-1]] {
                qSum = qSum[:len(qSum)-1]
        }
        // Кладу "запрос на сумму больше" в очередь:
        //  "число numOver и выше ожидается для получения суммы k от позиции i"
        qSum = append(qSum, i) // [3,0][4,1]
    }
    
    if minLen == 1<<32 {
        return -1
    }

    return minLen
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

/*
Example 1:

Input: nums = [1], k = 1
Output: 1
Example 2:

Input: nums = [1,2], k = 4
Output: -1
Example 3:

Input: nums = [2,-1,2], k = 3
Output: 3

1 <= nums.length <= 105
-105 <= nums[i] <= 105
1 <= k <= 109
*/
